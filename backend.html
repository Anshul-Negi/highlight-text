<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Headline Highlighter Animator</title>
<style>
  :root {
    --bg: #ffffff;
    --panel: #f5f5f5;
    --text: #111827;
    --muted: #6b7280;
    --brand: #ffeb3b;
    --border: #e5e7eb;
  }
  * { box-sizing: border-box }
  body {
    margin: 0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Inter, Roboto, Arial;
    background: var(--bg);
    color: var(--text);
    padding: 24px 18px 24px 18px;
  }
  header {
    padding: 14px 16px;
    border-bottom: 1px solid var(--border);
    display: flex; gap: 10px; align-items: center; justify-content: space-between;
    background: var(--bg);
  }
  header .title { font-size: 15px; font-weight: 700 }
  .app {
    display: grid;
    grid-template-columns: 320px 1fr;
    gap: 14px;
    padding: 24px;
    min-height: calc(100vh - 54px);
  }
  .panel {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 12px;
  }
  .panel h2 { margin: 0 0 12px 0; font-size: 13px; color: var(--muted); font-weight: 700; letter-spacing: .2px }
  .control { margin-bottom: 14px }
  .control label { display:block; font-size:13px; color:var(--text); margin-bottom:8px; font-weight: 500 }
  .row { display:flex; gap:10px; align-items:center; flex-wrap: wrap }
  select, input[type="color"], input[type="range"], input[type="file"] {
    width: 100%; background:#fff; color:var(--text); border:1px solid #d1d5db; border-radius:10px; padding:8px
  }
  input[type="range"] { padding:0 }
  button {
    background:#f3f4f6; color:var(--text); border:1px solid #d1d5db; padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:600; font-size:12px
  }
  button.primary { background:#ffe066; border-color:#ffe066; color:#111827; }
  button:disabled { opacity:.6; cursor:not-allowed }
  .stage {
    background:#fff; border:1px solid var(--border); border-radius:14px; padding:10px; position:relative
  }
  #canvasWrap { position:relative; width:100%; height:78vh; border-radius:12px; overflow:hidden; background:#f3f4f6 }
  canvas { width:100%; height:100%; display:block }
  .hint { color:var(--muted); font-size:12px }
  .status { color:var(--muted); font-size:12px; padding-top:8px }

  .snack {
    position: fixed; left: 16px; bottom: 16px; background:#fffbe6; border:1px solid #ffe066; color:#111827;
    padding:10px 12px; border-radius:10px; display:flex; gap:10px; align-items:center; z-index:50;
    box-shadow:0 8px 24px rgba(0,0,0,.08)
  }
  .snack.hidden { display:none }
  .snack button { padding:6px 10px; border-radius:8px }

  /* Responsive layout */
  @media (max-width: 1024px) {
    .app { grid-template-columns: 1fr; padding: 18px; }
    #canvasWrap { height: 68vh }
  }
  @media (max-width: 640px) {
    #canvasWrap { height: 58vh }
    .export-buttons { flex-direction: column }
    .app { padding: 10px; }
  }

  /* Export buttons styling */
  .export-buttons {
    display: flex;
    gap: 10px;
    margin-top: 12px;
  }
  
  .export-btn {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    font-size: 12px;
    padding: 12px 10px;
    border-radius: 10px;
    background: #ffe066;
    border: 1px solid #ffe066;
    color: #111827;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.2s ease;
  }
  
  .export-btn:hover {
    background: #fff176;
    border-color: #ffe066;
  }
  
  .export-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
  
  .export-btn img {
    width: 16px;
    height: 16px;
    opacity: 0.8;
  }
  
  .export-btn.video {
    background: #e3f2fd;
    border-color: #90caf9;
    color: #1565c0;
  }
  
  .export-btn.video:hover {
    background: #bbdefb;
    border-color: #64b5f6;
  }
  
  .export-btn.image {
    background: #e8f5e9;
    border-color: #a5d6a7;
    color: #1b5e20;
  }
  
  .export-btn.image:hover {
    background: #c8e6c9;
    border-color: #81c784;
  }

  /* Color input styling */
  input[type="color"] {
    height: 36px;
    border: 2px solid #d1d5db;
    border-radius: 8px;
    cursor: pointer;
  }
  input[type="color"]::-webkit-color-swatch-wrapper {
    padding: 0;
  }
  input[type="color"]::-webkit-color-swatch {
    border: none;
    border-radius: 6px;
  }
  input[type="color"]::-moz-color-swatch {
    border: none;
    border-radius: 6px;
  }
</style>
</head>
<body>
<header>
  <div class="title">Headline Highlighter Animator</div>
  <div class="hint">Tip: drag to draw, click to select, double-click to delete, Shift for thin bands</div>
</header>

<main class="app">
  <section class="panel">
    <h2>Inputs</h2>
    <div class="control">
      <label>Image file</label>
      <input id="file" type="file" accept="image/*" />
    </div>

    <div class="control">
      <label>Highlight shape</label>
      <select id="shape">
        <option value="rect">Rectangle</option>
        <option value="brush">Hand-Drawn Brush</option>
      </select>
    </div>

    <div class="control">
      <label>Color</label>
      <input id="color" type="color" value="#FFEB3B" />
    </div>

    <div class="control">
      <label>Opacity</label>
      <input id="opacity" type="range" min="0.1" max="1" step="0.05" value="0.9" />
    </div>

    <div class="control">
      <label>Corner radius (for Rectangle)</label>
      <input id="radius" type="range" min="0" max="60" step="2" value="18" />
    </div>

    <div class="control">
      <label>Duration (seconds)</label>
      <input id="duration" type="range" min="0.3" max="2.5" step="0.1" value="1.4" />
      <div class="hint" style="margin-top:4px; font-size:11px">Current: <span id="durationValue">1.4s</span></div>
    </div>

    <div class="control">
      <label>Animation style</label>
      <select id="animationMode">
        <option value="simultaneous">All at once</option>
        <option value="sequential">One by one</option>
      </select>
    </div>

    <div class="row" style="margin-top:16px; margin-bottom:12px">
      <button id="btnPreview" class="primary" title="Play preview">Preview</button>
      <button id="btnUndo" title="Undo last action (Ctrl/Cmd+Z)">Undo</button>
      <button id="btnClear" title="Remove all highlights">Clear All</button>
    </div>

    <div class="export-buttons">
      <button id="btnExportVideo" class="export-btn video" title="Generate animated video">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
          <path d="M8 5v14l11-7z"/>
        </svg>
        Generate Video
      </button>
      <button id="btnExportImage" class="export-btn image" title="Export static image">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
          <path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/>
        </svg>
        Export Image
      </button>
    </div>

    <div class="status" id="status" style="margin-top: 12px; padding: 8px; background: #f3f4f6; border-radius: 6px; border-left: 2px solid var(--brand); font-size: 11px;">Load an image, then drag to draw highlight areas.</div>
  </section>

  <section class="stage">
    <div id="canvasWrap">
      <canvas id="c"></canvas>
    </div>
    <div class="hint" style="padding-top:8px">Click inside a box to select and move it. Double-click a box to delete.</div>
  </section>
</main>

<div id="snack" class="snack hidden">
  <span id="snackMsg">Box added</span>
  <button id="snackUndo">Undo</button>
</div>

<script>
  const fileEl = document.getElementById('file');
  const shapeEl = document.getElementById('shape');
  const colorEl = document.getElementById('color');
  const opacityEl = document.getElementById('opacity');
  const radiusEl = document.getElementById('radius');
  const durationEl = document.getElementById('duration');
  const sizeEl = document.getElementById('exportSize');

  const statusEl = document.getElementById('status');
  const btnPreview = document.getElementById('btnPreview');
  const btnUndo = document.getElementById('btnUndo');
  const btnClear = document.getElementById('btnClear');
  const btnExportVideo = document.getElementById('btnExportVideo');
  const btnExportImage = document.getElementById('btnExportImage');
  const durationValueEl = document.getElementById('durationValue');
  const animationModeEl = document.getElementById('animationMode');

  const snack = document.getElementById('snack');
  const snackMsg = document.getElementById('snackMsg');
  const snackUndo = document.getElementById('snackUndo');

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  let imgBitmap = null;
  let scale = 1, offsetX = 0, offsetY = 0;

  const state = {
    boxes: [],         // [{x,y,w,h,seed}]
    activeIndex: -1,
    draggingNew: false,
    moving: false,
    resizing: false,
    resizeHandle: null, // 'nw','ne','sw','se','n','s','e','w'
    anchor: null,      // for draw/move
    previewing: false,
    lastTime: 0,
    progress: 0,
    fps: 30,
    history: []
  };

  function setStatus(t){ statusEl.textContent = t }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)) }

  function snapshot(){
    // deep copy boxes
    const copy = state.boxes.map(b => ({...b}));
    state.history.push(copy);
    if(state.history.length > 50) state.history.shift();
  }

  function undo(){
    if(state.history.length === 0) return;
    state.boxes = state.history.pop();
    state.activeIndex = -1;
    draw();
    setStatus('Undone');
  }

  function showSnack(msg, onUndo){
    snackMsg.textContent = msg;
    snack.classList.remove('hidden');
    const off = ()=> snack.classList.add('hidden');
    const undoClick = ()=>{
      off();
      if(onUndo) onUndo();
      snackUndo.removeEventListener('click', undoClick);
    };
    snackUndo.addEventListener('click', undoClick);
    setTimeout(off, 3500);
  }

  function roundedRectPath(ctx, x, y, w, h, r){
    const rr = Math.min(r, Math.abs(w)/2, Math.abs(h)/2);
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.lineTo(x + w - rr, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + rr);
    ctx.lineTo(x + w, y + h - rr);
    ctx.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
    ctx.lineTo(x + rr, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - rr);
    ctx.lineTo(x, y + rr);
    ctx.quadraticCurveTo(x, y, x + rr, y);
    ctx.closePath();
  }

  // Sketchy highlighter brush: uniform band with scalloped, hand-drawn edges
  // t in [0,1] controls reveal from left to right
  function brushPath(ctx, x, y, w, h, t, seed){
    const steps = 72;                 // more points for smoother waviness
    const sweepW = Math.max(1, w*t);  // animated width
    const midY = y + h/2;

    // Edge waviness amplitude (scaled by height)
    const ampBase = Math.min(10, h * 0.22);

    // Helper noise using a couple of sinusoids so we don't need perlin
    const noiseAt = (u, k=1) => {
      const p = seed * 0.015 * k;
      // Combine a few harmonics for a natural wobble
      return (
        Math.sin((u*10 + p) * Math.PI*2) * 0.55 +
        Math.sin((u*22.7 + p*1.7) * Math.PI*2) * 0.35 +
        Math.sin((u*5.3 + p*2.3) * Math.PI*2) * 0.20
      ) * 0.7; // normalize
    };

    // Fade edge waviness near ends to mimic rounded caps
    const endFade = (u) => {
      const edge = Math.min(u, 1-u);
      const s = Math.max(0, Math.min(1, edge/0.10)); // 0..1 inside 10% from ends
      return s*s*(3-2*s); // smoothstep
    };

    ctx.beginPath();
    // Top edge left->right
    for(let i=0;i<=steps;i++){
      const u = i/steps;        // 0..1 along the visible width
      const xx = x + sweepW*u;
      const amp = ampBase * (0.75 + 0.25*Math.sin(u*Math.PI*2 + seed*0.1));
      const topOffset = -h/2 + amp * noiseAt(u, 1) * endFade(u);
      const yy = midY + topOffset;
      if(i===0) ctx.moveTo(xx, yy); else ctx.lineTo(xx, yy);
    }

    // Bottom edge right->left
    for(let i=steps;i>=0;i--){
      const u = i/steps;
      const xx = x + sweepW*u;
      const amp = ampBase * (0.75 + 0.25*Math.cos(u*Math.PI*2 + seed*0.07));
      const botOffset = +h/2 + amp * noiseAt(u, 2) * endFade(u);
      const yy = midY + botOffset;
      ctx.lineTo(xx, yy);
    }
    ctx.closePath();
  }

  

  function fitImageToCanvas(){
    if(!imgBitmap) return;
    const wrap = document.getElementById('canvasWrap');
    const W = wrap.clientWidth;
    const H = wrap.clientHeight;
    canvas.width = W;
    canvas.height = H;

    const iw = imgBitmap.width;
    const ih = imgBitmap.height;
    const s = Math.min(W/iw, H/ih);
    scale = s;
    const dw = iw * s;
    const dh = ih * s;
    offsetX = (W - dw) / 2;
    offsetY = (H - dh) / 2;
    draw();
  }

  function draw(progress, mode = 'simultaneous'){
    ctx.fillStyle = '#f3f4f6';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    if(!imgBitmap) return;

    // Draw base image
    ctx.drawImage(imgBitmap, offsetX, offsetY, imgBitmap.width*scale, imgBitmap.height*scale);

    const r = parseFloat(radiusEl.value);
    const col = colorEl.value;
    const op = parseFloat(opacityEl.value);
    const useBrush = shapeEl.value === 'brush';

    // Draw highlights with multiply so it appears behind text
    state.boxes.forEach((b,i)=>{
      let sweep = 1;
      if(progress !== undefined) {
        if(mode === 'sequential') {
          // Sequential animation: each box gets its own timing
          const boxProgress = clamp((progress * state.boxes.length - i) / 1, 0, 1);
          sweep = boxProgress;
        } else {
          // Simultaneous animation: all boxes animate together
          sweep = clamp(progress, 0, 1);
        }
      }

      ctx.save();
      // Clip to full box region
      if(useBrush) {
        // Clip to full area using rounded rect so brush doesn't bleed
        roundedRectPath(ctx, b.x, b.y, b.w, b.h, Math.min(r, b.h/2));
      } else {
        roundedRectPath(ctx, b.x, b.y, b.w, b.h, r);
      }
      ctx.clip();

      ctx.globalAlpha = op;
      ctx.globalCompositeOperation = 'multiply';
      ctx.fillStyle = col;

      if(useBrush) {
        brushPath(ctx, b.x, b.y, b.w, b.h, sweep, b.seed || 1);
      } else {
        const animatedW = b.w * sweep;
        roundedRectPath(ctx, b.x, b.y, animatedW, b.h, r);
      }
      ctx.fill();
      ctx.restore();

      // Selection outline and resize handles
      ctx.save();
      ctx.strokeStyle = (i === state.activeIndex) ? 'rgba(255,255,255,0.95)' : 'rgba(255,255,255,0.7)';
      ctx.setLineDash([6,6]);
      ctx.lineWidth = 1;
      roundedRectPath(ctx, b.x, b.y, b.w, b.h, Math.min(r, b.h/2));
      ctx.stroke();
      if(i === state.activeIndex){
        const s = 6;
        const points = [
          {x:b.x, y:b.y}, {x:b.x+b.w, y:b.y}, {x:b.x, y:b.y+b.h}, {x:b.x+b.w, y:b.y+b.h}
        ];
        ctx.setLineDash([]);
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        points.forEach(pt=>{ ctx.fillRect(pt.x - s/2, pt.y - s/2, s, s) });
      }
      ctx.restore();
    });

    //
  }

  function canvasPos(e){
    const rect = canvas.getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
  }

  function indexAtPoint(p){
    for(let i=state.boxes.length-1;i>=0;i--){
      const b = state.boxes[i];
      if(p.x >= b.x && p.x <= b.x + b.w && p.y >= b.y && p.y <= b.y + b.h){
        return i;
      }
    }
    return -1;
  }

  function hitResizeHandle(p, b){
    const handleSize = 8;
    const corners = {
      nw: {x: b.x, y: b.y},
      ne: {x: b.x + b.w, y: b.y},
      sw: {x: b.x, y: b.y + b.h},
      se: {x: b.x + b.w, y: b.y + b.h}
    };
    for(const [key, pt] of Object.entries(corners)){
      if(Math.abs(p.x - pt.x) <= handleSize && Math.abs(p.y - pt.y) <= handleSize){
        return key;
      }
    }
    // edges
    if(Math.abs(p.x - b.x) <= handleSize && p.y >= b.y && p.y <= b.y + b.h) return 'w';
    if(Math.abs(p.x - (b.x + b.w)) <= handleSize && p.y >= b.y && p.y <= b.y + b.h) return 'e';
    if(Math.abs(p.y - b.y) <= handleSize && p.x >= b.x && p.x <= b.x + b.w) return 'n';
    if(Math.abs(p.y - (b.y + b.h)) <= handleSize && p.x >= b.x && p.x <= b.x + b.w) return 's';
    return null;
  }

  // HUD removed

  // Mouse handlers
  canvas.addEventListener('mousedown', (e)=>{
    if(!imgBitmap) return;
    const p = canvasPos(e);
    const hit = indexAtPoint(p);
    if(hit !== -1){
      state.activeIndex = hit;
      const b = state.boxes[hit];
      const handle = hitResizeHandle(p, b);
      if(handle){
        state.resizing = true;
        state.resizeHandle = handle;
        state.anchor = { startX: b.x, startY: b.y, startW: b.w, startH: b.h, px: p.x, py: p.y };
        setStatus('Resizing');
      } else {
        state.moving = true;
        state.draggingNew = false;
        state.anchor = { dx: p.x - b.x, dy: p.y - b.y };
        setStatus('Moving selection');
      }
      draw();
    } else {
      snapshot(); // snapshot before creating
      state.moving = false;
      state.draggingNew = true;
      state.activeIndex = state.boxes.length;
      state.anchor = { x: p.x, y: p.y };
      state.boxes.push({ x: p.x, y: p.y, w: 1, h: 1, seed: Math.floor(Math.random()*10000) });
      setStatus('Drawing selection');
      showSnack('Box added', ()=> undo());
    }
  });

  window.addEventListener('mousemove', (e)=>{
    if(!imgBitmap) return;
    const p = canvasPos(e);
    if(state.draggingNew){
      const x0 = state.anchor.x;
      const y0 = state.anchor.y;
      const w = p.x - x0;
      const h = p.y - y0;
      const idx = state.activeIndex;
      const hCon = clamp(Math.abs(h), 20, 300);
      if(e.shiftKey){
        state.boxes[idx] = { x: Math.min(x0, p.x), y: y0, w: Math.abs(w), h: hCon, seed: state.boxes[idx].seed };
      } else {
        state.boxes[idx] = { x: Math.min(x0, p.x), y: Math.min(y0, p.y), w: Math.abs(w), h: Math.abs(h), seed: state.boxes[idx].seed };
      }
      draw();
    } else if(state.resizing && state.activeIndex > -1){
      const b = state.boxes[state.activeIndex];
      const a = state.anchor;
      let { startX, startY, startW, startH } = a;
      const dx = p.x - a.px;
      const dy = p.y - a.py;
      let x = startX, y = startY, w = startW, h = startH;
      switch(state.resizeHandle){
        case 'nw': x = startX + dx; y = startY + dy; w = startW - dx; h = startH - dy; break;
        case 'ne': y = startY + dy; w = startW + dx; h = startH - dy; break;
        case 'sw': x = startX + dx; w = startW - dx; h = startH + dy; break;
        case 'se': w = startW + dx; h = startH + dy; break;
        case 'n':  y = startY + dy; h = startH - dy; break;
        case 's':  h = startH + dy; break;
        case 'w':  x = startX + dx; w = startW - dx; break;
        case 'e':  w = startW + dx; break;
      }
      // enforce minimums
      w = Math.max(10, w); h = Math.max(10, h);
      state.boxes[state.activeIndex] = { ...b, x, y, w, h };
      draw();
    } else if(state.moving && state.activeIndex > -1){
      const b = state.boxes[state.activeIndex];
      b.x = p.x - state.anchor.dx;
      b.y = p.y - state.anchor.dy;
      draw();
    }
  });

  window.addEventListener('mouseup', ()=>{
    if(state.draggingNew || state.moving || state.resizing) setStatus('Box ready. You can add more or Preview.');
    state.draggingNew = false;
    state.moving = false;
    state.resizing = false;
    state.resizeHandle = null;
  });

  // Select on click, delete on double-click
  canvas.addEventListener('click', (e)=>{
    const p = canvasPos(e);
    const hit = indexAtPoint(p);
    state.activeIndex = hit;
    // Change cursor if near resize handles
    if(hit !== -1){
      const handle = hitResizeHandle(p, state.boxes[hit]);
      const cursorMap = { nw:'nwse-resize', se:'nwse-resize', ne:'nesw-resize', sw:'nesw-resize', n:'ns-resize', s:'ns-resize', e:'ew-resize', w:'ew-resize' };
      canvas.style.cursor = handle ? cursorMap[handle] : 'move';
    } else {
      canvas.style.cursor = 'default';
    }
    draw();
  });

  canvas.addEventListener('dblclick', (e)=>{
    const p = canvasPos(e);
    const hit = indexAtPoint(p);
    if(hit !== -1){
      snapshot();
      state.boxes.splice(hit,1);
      state.activeIndex = -1;
      draw();
      setStatus('Deleted selection');
    }
  });

  // Update cursor on move to indicate resize handles
  canvas.addEventListener('mousemove', (e)=>{
    const p = canvasPos(e);
    const hit = indexAtPoint(p);
    if(hit !== -1){
      const handle = hitResizeHandle(p, state.boxes[hit]);
      const cursorMap = { nw:'nwse-resize', se:'nwse-resize', ne:'nesw-resize', sw:'nesw-resize', n:'ns-resize', s:'ns-resize', e:'ew-resize', w:'ew-resize' };
      canvas.style.cursor = handle ? cursorMap[handle] : (state.moving ? 'grabbing' : 'move');
    } else {
      canvas.style.cursor = 'default';
    }
  });

  // Keyboard Undo and Delete (Delete or Backspace)
  window.addEventListener('keydown', (e)=>{
    const meta = e.ctrlKey || e.metaKey;
    if(meta && e.key.toLowerCase() === 'z'){ e.preventDefault(); undo() }
    if((e.key === 'Delete' || e.key === 'Backspace') && state.activeIndex > -1){
      snapshot();
      state.boxes.splice(state.activeIndex,1);
      state.activeIndex = -1;
      draw();
      setStatus('Deleted selection');
    }
  });

  // Delete via keyboard only (Delete or Backspace)

  // Image load
  fileEl.addEventListener('change', async (e)=>{
    const f = e.target.files[0];
    if(!f) return;
    
    try {
      // Use FileReader to convert to data URL instead of blob URL
      const reader = new FileReader();
      reader.onload = async (event) => {
        const img = new Image();
        img.onload = async () => {
          imgBitmap = await createImageBitmap(img);
          state.boxes = [];
          state.activeIndex = -1;
          state.history = [];
          fitImageToCanvas();
          setStatus('Image loaded. Draw one or more highlight areas.');
        };
        img.onerror = () => {
          setStatus('Error loading image');
        };
        img.src = event.target.result;
      };
      reader.onerror = () => {
        setStatus('Error reading file');
      };
      reader.readAsDataURL(f);
    } catch (error) {
      setStatus('Error processing image file');
    }
  });

  new ResizeObserver(fitImageToCanvas).observe(document.getElementById('canvasWrap'));
  window.addEventListener('resize', fitImageToCanvas);

  // Preview animation with sequential or simultaneous options
  let rafId = null;
  function startPreview(){
    if(!imgBitmap || state.boxes.length === 0){ setStatus('Load image and draw at least one box.'); return }
    // Cancel any prior RAF and reset
    if (typeof rafId === 'number' && rafId) { cancelAnimationFrame(rafId); rafId = null; }
    state.previewing = true;
    state.progress = 0;
    state.lastTime = performance.now();
    const dur = parseFloat(durationEl.value) * 1000;
    const mode = animationModeEl.value;

    function tick(now){
      const dt = now - state.lastTime;
      state.lastTime = now;
      state.progress += dt / dur;
      if(state.progress > 1) state.progress = 1;
      draw(state.progress, mode);
      if(state.progress < 1 && state.previewing){
        rafId = requestAnimationFrame(tick);
      } else {
        state.previewing = false;
        // Keep final frame on canvas after preview completes
        state.progress = 1;
        draw(1, mode);
        setStatus('Preview finished');
      }
    }
    setStatus('Previewing…');
    rafId = requestAnimationFrame(tick);
  }

  btnPreview.addEventListener('click', startPreview);

  btnUndo.addEventListener('click', undo);
  btnClear.addEventListener('click', ()=>{
    if(state.boxes.length === 0) return;
    snapshot();
    state.boxes = [];
    state.activeIndex = -1;
    draw();
    setStatus('Cleared all');
  });

  // Function to check supported codec
  function getSupportedCodec() {
    const codecs = [
      'video/mp4;codecs=avc1.42E01E,mp4a.40.2',  // H.264 + AAC
      'video/mp4;codecs=avc1.42E01E',             // H.264 only
      'video/mp4',                                // Generic MP4
      'video/webm;codecs=vp9',                    // Fallback to WebM VP9
      'video/webm;codecs=vp8',                    // Fallback to WebM VP8
      'video/webm'                                // Generic WebM
    ];
    
    for (const codec of codecs) {
      if (MediaRecorder.isTypeSupported(codec)) {
        return codec;
      }
    }
    
    // If nothing is supported, return empty string and let MediaRecorder use default
    return '';
  }

  // Export MP4 (multiple boxes, both shapes)
  async function exportMP4(){
    if(!imgBitmap || state.boxes.length === 0){ setStatus('Load image and draw at least one box.'); return }
    // Stop any running preview to avoid RAF overlap with export
    if (typeof rafId === 'number' && rafId) { cancelAnimationFrame(rafId); rafId = null; }
    state.previewing = false; state.progress = 0;
    btnExportVideo.disabled = true; btnExportImage.disabled = true; btnPreview.disabled = true;
    setStatus('Generating video…');

    const expCanvas = document.createElement('canvas');
    const expCtx = expCanvas.getContext('2d', { alpha: false });

    // Use source image size for export
    const targetW = imgBitmap.width;
    const targetH = imgBitmap.height;

    expCanvas.width = targetW; expCanvas.height = targetH;

    const s = Math.min(targetW / imgBitmap.width, targetH / imgBitmap.height);
    const dw = imgBitmap.width * s;
    const dh = imgBitmap.height * s;
    const dx = (targetW - dw) / 2;
    const dy = (targetH - dh) / 2;

    const mapped = state.boxes.map(b=>({
      x: dx + ((b.x - offsetX) / (imgBitmap.width * scale)) * dw,
      y: dy + ((b.y - offsetY) / (imgBitmap.height * scale)) * dh,
      w: (b.w / (imgBitmap.width * scale)) * dw,
      h: (b.h / (imgBitmap.height * scale)) * dh,
      seed: b.seed
    }));

    const fps = state.fps;
    const durationMs = parseFloat(durationEl.value) * 1000;
    const totalFrames = Math.max(1, Math.round(fps * (durationMs/1000)));

    const stream = expCanvas.captureStream(fps);
    const chunks = [];
    
    // Get the best supported codec
    const supportedCodec = getSupportedCodec();
    let recorder;
    
    try {
      if (supportedCodec) {
        recorder = new MediaRecorder(stream, { mimeType: supportedCodec });
      } else {
        recorder = new MediaRecorder(stream); // Use default
      }
    } catch (error) {
      setStatus('Error: MediaRecorder not supported');
      btnExportVideo.disabled = false; btnExportImage.disabled = false; btnPreview.disabled = false;
      return;
    }

    recorder.ondataavailable = e => { if(e.data.size) chunks.push(e.data) };
    const done = new Promise(res => { recorder.onstop = () => res() });
    
    recorder.start();
    // Give the recorder one frame to start so the first exported frame isn't blank
    await new Promise(r => requestAnimationFrame(r));
    // Small buffer to ensure stream is flowing on some browsers
    await new Promise(r => setTimeout(r, 50));

    for(let f=0; f<=totalFrames; f++){
      const t = f/totalFrames;

      // Base
      expCtx.fillStyle = '#f3f4f6';
      expCtx.fillRect(0,0,targetW,targetH);
      expCtx.drawImage(imgBitmap, dx, dy, dw, dh);

      // Highlights
      const col = colorEl.value;
      const op = parseFloat(opacityEl.value);
      const r = parseFloat(radiusEl.value);
      const useBrush = shapeEl.value === 'brush';
      const mode = animationModeEl.value;

      mapped.forEach((b,i)=>{
        let sweep = t;
        if(mode === 'sequential') {
          // Sequential animation: each box gets its own timing
          const boxProgress = clamp((t * mapped.length - i) / 1, 0, 1);
          sweep = boxProgress;
        }

        expCtx.save();
        if(useBrush){
          roundedRectPath(expCtx, b.x, b.y, b.w, b.h, Math.min(r, b.h/2));
        } else {
          roundedRectPath(expCtx, b.x, b.y, b.w, b.h, r);
        }
        expCtx.clip();
        expCtx.globalAlpha = op;
        expCtx.globalCompositeOperation = 'multiply';
        expCtx.fillStyle = col;

        if(useBrush){
          brushPath(expCtx, b.x, b.y, b.w, b.h, sweep, b.seed || 1);
        } else {
          const w = b.w * sweep;
          roundedRectPath(expCtx, b.x, b.y, w, b.h, r);
        }
        expCtx.fill();
        expCtx.restore();
      });

      // Pace frames to the target FPS to ensure recorder gets distinct frames
      await new Promise(r => setTimeout(r, Math.max(0, Math.round(1000 / fps))));
    }

    // Flush any pending data before stopping
    try { recorder.requestData(); } catch(e) {}
    recorder.stop();
    await done;

    // Determine file extension based on the codec used
    let fileExtension = 'mp4';
    let mimeType = 'video/mp4';
    
    if (supportedCodec.includes('webm')) {
      fileExtension = 'webm';
      mimeType = 'video/webm';
    }

    const blob = new Blob(chunks, {type: mimeType});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; 
    a.download = `headline-highlight.${fileExtension}`;
    document.body.appendChild(a); 
    a.click(); 
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 2000);

    setStatus(`Video generated (${fileExtension.toUpperCase()})`);
    btnExportVideo.disabled = false; btnExportImage.disabled = false; btnPreview.disabled = false;
  }

  // Export static image
  async function exportImage(){
    if(!imgBitmap || state.boxes.length === 0){ setStatus('Load image and draw at least one box.'); return }
    btnExportVideo.disabled = true; btnExportImage.disabled = true; btnPreview.disabled = true;
    setStatus('Generating image…');

    const expCanvas = document.createElement('canvas');
    const expCtx = expCanvas.getContext('2d', { alpha: false });

    // Use source image size for export
    const targetW = imgBitmap.width;
    const targetH = imgBitmap.height;

    expCanvas.width = targetW; expCanvas.height = targetH;

    const s = Math.min(targetW / imgBitmap.width, targetH / imgBitmap.height);
    const dw = imgBitmap.width * s;
    const dh = imgBitmap.height * s;
    const dx = (targetW - dw) / 2;
    const dy = (targetH - dh) / 2;

    const mapped = state.boxes.map(b=>({
      x: dx + ((b.x - offsetX) / (imgBitmap.width * scale)) * dw,
      y: dy + ((b.y - offsetY) / (imgBitmap.height * scale)) * dh,
      w: (b.w / (imgBitmap.width * scale)) * dw,
      h: (b.h / (imgBitmap.height * scale)) * dh,
      seed: b.seed
    }));

    // Draw base image
    expCtx.fillStyle = '#f3f4f6';
    expCtx.fillRect(0,0,targetW,targetH);
    expCtx.drawImage(imgBitmap, dx, dy, dw, dh);

    // Draw highlights (fully revealed)
    const col = colorEl.value;
    const op = parseFloat(opacityEl.value);
    const r = parseFloat(radiusEl.value);
    const useBrush = shapeEl.value === 'brush';

    mapped.forEach(b=>{
      expCtx.save();
      roundedRectPath(expCtx, b.x, b.y, b.w, b.h, Math.min(r, b.h/2));
      expCtx.clip();
      expCtx.globalAlpha = op;
      expCtx.globalCompositeOperation = 'multiply';
      expCtx.fillStyle = col;

      if(useBrush){
        brushPath(expCtx, b.x, b.y, b.w, b.h, 1, b.seed || 1);
      } else {
        roundedRectPath(expCtx, b.x, b.y, b.w, b.h, r);
      }
      expCtx.fill();
      expCtx.restore();
    });

    // Convert to blob and download
    expCanvas.toBlob((blob) => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'headline-highlight.png';
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 2000);
      
      setStatus('Image exported (PNG)');
      btnExportVideo.disabled = false; btnExportImage.disabled = false; btnPreview.disabled = false;
    }, 'image/png');
  }

  btnExportVideo.addEventListener('click', exportMP4);
  btnExportImage.addEventListener('click', exportImage);

  // Update duration display
  durationEl.addEventListener('input', () => {
    durationValueEl.textContent = durationEl.value + 's';
    draw();
  });

  // Redraw on control changes
  ;[shapeEl, colorEl, opacityEl, radiusEl].forEach(el=>{
    el.addEventListener('input', ()=> draw());
  });
</script>
</body>
</html>
